"""
Module for automatically filling in pdf forms
"""

import json
import os
import uuid
from collections import OrderedDict
from enum import Enum

import numpy as np
from faker import Faker
from faker_vehicle import VehicleProvider
from fitz import fitz

locales = OrderedDict([
    ('fr-FR', 1)])

class DateFormats(Enum):
    """
    Enum class defining the possible date formats to use in text areas.
    """
    NUMERIC = ['%d-%m-%Y', '%d/%m/%Y', '%d-%m-%y', '%d/%m/%Y']
    STR = ['%d %B %Y', '%d %B %y']
    NUMERIC_OR_STR = NUMERIC + STR

class Annotator():
    """
    Create a json file containing the labels associated with a pdf. The labels are the values automatically
    generated by the Writer.
    """
    def __init__(self):
        self.dic = {}

    def add(self, field,loc, value):
        self.dic.update({ str(loc):(field,value)})

    def save(self, filename:str):
        self.filename = filename
        with open(filename, "w") as f:
            json.dump(self.dic,f)

class Writer(object):
    """
    Before creating a new writer, you need to place a cerfa_{num_cerfa}.pdf file and cerfa_{num_cerfa}.json
    file into folder data/CERFA/toFill. The pdf file is the empty template, and the json file is the mapping
    indicating the semantic for each text field. You need to extend this Writer with a child classe dedicated to
    the cerfa you want. In the __init__ of the child class, you need to specify a dictionnary D mapping field types
    with functions to fill them.
    """
    @classmethod
    def get_subclasses(cls):
        for subclass in cls.__subclasses__():
            yield subclass

    def __init__(self, num_cerfa:str):
        """
        In the __init__ of the child class, you need to specify a dictionnary D mapping field types
        with functions to fill them.
        :param num_cerfa: cerfa number as string.
        """
        self.fake = Faker(locales)
        self.fake.add_provider(VehicleProvider)
        _input_filepath = f"data/CERFA/toFill/cerfa_{num_cerfa}.pdf"
        _param_filepath = f"data/CERFA/toFill/cerfa_{num_cerfa}.json"
        self.output_filepath = "output/{}/cerfa_{}_v{}.pdf"

        self.doc = fitz.open(_input_filepath)

        self.params = json.load(open(_param_filepath, 'rb'))
        self.num_cerfa = num_cerfa

        self.radio_buttons_values = {}
        self.radio_buttons_group_len = {}
        self.__clear_radio_buttons__()
        self.D = {}
        self.annotator = None

    def __clear_radio_buttons__(self):
        """
        Deactivate all radio buttons on the form before processing the file.
        :return: None
        """
        for p in range(self.doc.page_count):
            page = self.doc[p]
            _field = page.first_widget

            while _field:
                if _field.field_type == 5:
                    _field.field_value = 0
                    _field.update()
                    group_len = self.radio_buttons_group_len.get(_field.field_name, 0)
                    self.radio_buttons_group_len[_field.field_name] = group_len + 1
                _field = _field.next

    # -----------------------------------------------------------------------------------------------------------
    # The following functions fill the different kind of widgets : text, checkbox, radio ...
    # -----------------------------------------------------------------------------------------------------------
    def fill_text(self, field:fitz.fitz.Widget):
        """
        Fills a text area with a value depending on the mapping defined in the self.D dictionary,
        and the json file associated to the pdf.

        :param fitz.fitz.Widget field: The widget we want to fill (text area in this case)
        :return: None
        """
        for key in self.D.keys():
            values = self.params.get(key, None)
            if values and isinstance(values, list):
                if any(value.lower() in field.field_name.lower() for value in values):
                    try:  # Faker functions are called without argument
                        val = self.D[key]()
                    except KeyError:  # Writer's own functions may contain arguments
                        val = self.D[key](field=field)
                    field.field_value = val
                    field.update()
                    self.annotator.add(field.field_name, field.rect, val)
                    break

            elif values and isinstance(values, dict):
                for k in values.keys():
                    if k.lower() in field.field_name.lower():
                        # val = self.D[key]({"field": field, "param_value": values[k]})
                        val = self.D[key](field= field, param_value = values[k])
                        field.field_value = str(val)
                        field.update()
                        break

    def fill_checkbox(self, _field):
        """
        Automatically fill all checkboxes with a 50/50 chance
        :param fitz.fitz.Widget _field: Text box we want to process
        :return: None
        """
        val = self.fake.boolean(chance_of_getting_true=50)
        _field.field_value = val
        _field.update()
        self.annotator.add(_field.field_name, _field.rect, val)

    def fill_radio(self, _field):
        """
        Automatically fill all radio groups according to uniform law
        :param fitz.fitz.Widget _field: The radio button we want to process
        :return: None
        """
        if _field is None:
            return
        # We ensure that 1 and only 1 button within the group is activated
        group = self.radio_buttons_values.get(_field.field_name, np.array([]))
        group_already_has_active_button = any(group == 1)
        if not group_already_has_active_button:
            # If no button has been selected and this is the last one in the group => Activate it
            is_last_group_button = _field.next and _field.next.field_name != _field.field_name
            if is_last_group_button:
                val = 1
            else:
                # Proba to press button = 1 / nb_boutons
                chance_of_getting_true = 1 / self.radio_buttons_group_len[_field.field_name] * 100
                val = self.fake.boolean(chance_of_getting_true=chance_of_getting_true)
            _field.field_value = val
            _field.update()
            self.radio_buttons_values[_field.field_name] = np.insert(group, len(group), val)

            self.annotator.add(_field.field_name, _field.rect, val)

    #TODO Add function to handle dropdown list

    # -----------------------------------------------------------------------------------------------------------
    # The following functions are helpers to fill a text box with specific semantics
    # -----------------------------------------------------------------------------------------------------------
    def fill_date(self, **kwargs):
        """
        Function used to fill a text area with a date, in a given format.
        :param fitz.fitz.Widget field: text area to fill
        :param str param_value: The format for the date. If empty, will use one random among
                    DateFormats.NUMERIC_OR_STR
        :return: The date to insert (as string)
        """
        try:
            _field, param_key = kwargs["field"], kwargs["param_value"]
        except:
            raise ValueError("Function fill_date expects keyword arguments 'field' and 'param_value'. "
                             "Check docstring for details.")

        _format = param_key
        if _format == "": _format = self.fake.random_element(elements=DateFormats.NUMERIC_OR_STR.value)
        return self.fake['fr-FR'].date(pattern=_format)

    def fill_paragraph(self, **kwargs):
        """
        Fill a text area with a paragraph containing between 1 and 3 sentences, and a maximum of 1000 characters.
        :param fitz.fitz.Widget field: text area to fill
        :return: The text to insert
        """
        _field = kwargs["field"]
        max_chars = _field.text_maxlen if _field.text_maxlen > 0 else 1000
        return self.fake['fr-FR'].paragraph(nb_sentences=3, variable_nb_sentences=True)[:max_chars]

    def fill_siren_siret(self, **kwargs):
        """
        Fill a text area with a siren or a siret (50/50 chance)
        :param fitz.fitz.Widget field: text area to fill
        :param kwargs: Not used. In the signature for compatibility reasons
        :return: siren or siret, with no spaces between digits
        """
        return self.fake['fr-FR'].siren().replace(" ", "") if self.fake.boolean(chance_of_getting_true=50) \
            else self.fake['fr-FR'].siret().replace(" ", "")

    def fill_siret(self, **kwargs):
        """
        Fill a text area with a siret
        :param kwargs: Not used. In the signature for compatibility reasons
        :return: The siret number with no space between digits
        """
        return self.fake['fr-FR'].siret().replace(" ", "")

    def fill_txt_pattern(self, **kwargs):
        """
        Call function bothify of faker with the required pattern.
        :param fitz.fitz.Widget field: text area to fill
        :param str param_value: The pattern to use

        :return: The string processed by bothify
        """
        _field, pattern = kwargs["field"], kwargs["param_value"]
        return self.fake.bothify(text=pattern)

    def fill_digit_interval(self, **kwargs):
        """
        Sample a digit within a given interval.
        :param fitz.fitz.Widget field: text area to fill
        :param tuple param_value: A tuple containing the min/max bounds

        :return: The sampled number
        """
        _field, interval = kwargs["field"], kwargs["param_value"]
        min, max = interval
        return self.fake.random_int(min, max)

    def choice(self,**kwargs):
        """
        Select a random element within a list
        :param fitz.fitz.Widget field: text area to fill
        :param tuple param_value: The list of elements to choose from

        :return: The selected element
        """
        _field, choices = kwargs["field"], kwargs["param_value"]
        return self.fake.random_elements(elements=choices, length=1)[0]

    # -----------------------------------------------------------------------------------------------------------
    # The following functions iterate over the pages and fields of the form to fill it
    # -----------------------------------------------------------------------------------------------------------

    def fill_page(self, field):
        """
        Fill all the fields of pdf document's page
        :param fitz.fitz.Widget field: The first widget of the page
        :return: None
        """
        while field:
            if field.field_type == 7:
                self.fill_text(field)

            elif field.field_type == 5:
                self.fill_radio(field)

            elif field.field_type == 2:
                self.fill_checkbox(field)

            field = field.next

    def fill_form(self):
        """
        Fill all the pages of pdf form.
        :return: None
        """
        self.annotator = Annotator()
        for p in range(self.doc.page_count):
            page = self.doc[p]
            field = page.first_widget
            self.fill_page(field)

    # -----------------------------------------------------------------------------------------------------------
    # Save filled-in document on disk
    # -----------------------------------------------------------------------------------------------------------

    def save(self):
        """
        Save a form as pdf and its annotations as json into the output/{cerfa_number} directory.
        :return:
        """
        out_pdf = self.output_filepath.format(self.num_cerfa, self.num_cerfa, uuid.uuid4().hex)

        if not os.path.exists(out_pdf):
            os.makedirs(out_pdf)

        self.doc.save(out_pdf)
        labels_path = out_pdf[:-3] + "json"
        self.annotator.save(labels_path)